"""P2S10 TD3 v5 with 40x40 front and orientation from ac3.ipynb

Automatically generated by Colaboratory.


# Twin-Delayed DDPG

On a custom car env
state:
1. 40x40 cutout: 25 embeddings || car is at mid ( grid embeddings)
2. 25 cnn embeddings `+` [distance, orientation, -orientation, self.angle, -self.angle]
NOTE: Embeddings are actually 25 rectangles

Action space: angle and speed with range[-20,20]
    NOTE: predicted action speed is interpolated b/w [3,6]


TODO: add Dabba delivery system in place ?? DONE
TODO: Rendor CNN coutput as LIDAR box
"""

import gym
import numpy as np
import skimage.measure
import sys
import copy
import random
import math
from gym import spaces, error
from gym.utils import seeding

import pygame

from PIL import Image as PILImage
import os
import cv2
import scipy.ndimage


os.environ['SDL_VIDEO_CENTERED'] = "True"


class DabbeWalaEnv(gym.Env):
    metadata = {'render.modes': ['human', 'console'],
                'video.frames_per_second':100}

    def __init__(self, seed=None):
        # self.seed = seed
        # if seed is None:
        #     self.seed = random.randint(0, sys.maxsize)
        path = './images'
        self.seed()
        
        
        self.bg = pygame.image.load(os.path.join(path, 'citymap.png'))
        self.window_width, self.window_height = self.bg.get_size()
        # for convolutions//state extraction
        self.sand = np.asarray(PILImage.open(os.path.join(path, "MASK1.png")).convert('L'))/255
        
        # for rendering
        self.dabba = pygame.transform.scale(pygame.image.load(os.path.join(path, 'dabba.png')), (30,30))
        self.delivery = pygame.transform.scale(pygame.image.load(os.path.join(path, 'delivery.png')), (50,50))

        #spawn car
        self.car_img = pygame.transform.scale(pygame.image.load(os.path.join(path, 'car.png')), (20,10))
        self.car = self.car_img.get_rect()        
        self.car.centerx = self.window_width//2
        self.car.centery = self.window_height//2
        self.car.width = 20
        self.car.height = 10
        self.speed = 5  # in pixels

        self.angle = 0  # car's angle from x axis, degree for now      
        
        # self.goal_x = 163 # x-coordinate of the goal
        # self.goal_y = 539# y-coordinate of the goal
        
        self.last_distance = 0
        self.last_reward = 0
        self.swap = 0
               
        # 'inspired from gym env'
        self.max_episode_steps = 2000 #baaki baad me dekhte hai

        
        self.max_action = 20 #action angle in degree
        self.action_space = spaces.Box(-self.max_action, self.max_action, shape=(2,))

        self.state_size = 40 #cutout for convolutions
        # making it mini tesla autopilot // did work a bit, but at what cost???
        # self.observation_space = spaces.Dict({"left": spaces.Box(low=0, high=1, shape=(self.state_size, self.state_size, 1), dtype=np.float64),
        #                                       "ahead": spaces.Box(low=0, high=1, shape=(self.state_size, self.state_size, 1), dtype=np.float64),
        #                                       "right": spaces.Box(low=0, high=1, shape=(self.state_size, self.state_size, 1), dtype=np.float64),
        #                                       "orientation": spaces.Discrete(4,)})
        self.observation_space = spaces.Dict({"surround": spaces.Box(low=0, high=1, shape=(self.state_size, self.state_size, 1), dtype=np.float64),
                                              "orientation": spaces.Discrete(5,)})
        self.reset()

    def reset(self):
        """
        This function resets the environment and returns the game state.
        """
        #Get Pickup A and  Delivery B
        pw = 150
        crop_sand = np.pad(self.sand[pw:-pw,pw:-pw], pad_width=((pw, pw), (pw, pw)), mode='constant', constant_values=1)
        y, x = np.where(crop_sand == 0) # pixels of the road
        
        #spawning the car
        k = self.np_random.randint(len(x))
        self.car.centerx, self.car.centery = int(x[k]), int(y[k])
        # self.car.centerx = self.np_random.randint(12, 1417)
        # self.car.centery = self.np_random.randint(12, 610)
        
        i = self.np_random.randint(len(x))
        j = self.np_random.randint(len(x))
        #Pickup : A Dabba
        self.x1, self.y1 = int(x[i]), int(y[i])
        #Delivery : B
        self.x2, self.y2 = int(x[j]), int(y[j]) 
        
        # #Pickup : A Dabba
        # self.x1, self.y1 = int(163), int(539)
        # #Delivery : B
        # self.x2, self.y2 = int(1196), int(148) 

        # Fist Target A
        self.goal_x, self.goal_y = self.x1, self.y1
        self.swap = 0   # resetting the destinations
        self.last_distance = 0
        self.last_reward = 0
        
        self.angle = 0  # car's angle from x axis, degree for now
        self.rotation = 0 #rotation// the action// just the initialization
        self.speed = 5  # in pixels // just init

        # for rendering most of the stuff is same, 
        # just new angle and car.centerx, car.centery should suffice        
        self.screen = None
        # to show off
        self.lidar = pygame.surfarray.make_surface(np.zeros((self.state_size,self.state_size)))
        self.surr = pygame.surfarray.make_surface(np.zeros((self.state_size,self.state_size)))

        return self._get_state()

    def render(self, mode='human', close=False):
        """
        This function renders the current game state in the given mode.
        TODO : render using default gym functions

        """
        if mode == 'console':
            print(self._get_state)
        elif mode == "human":
            try:
                import pygame
            except ImportError as e:
                raise error.DependencyNotInstalled(
                    "{}. (HINT: pygame install kar mere bhai; use `pip install pygame`".format(e))
            if close:
                pygame.quit()
            else:
                if self.screen is None:
                    pygame.init()
                    
                    self.screen = pygame.display.set_mode(
                        (round(self.window_width), round(self.window_height)))
                clock = pygame.time.Clock()
                myfont = pygame.font.SysFont('Comic Sans MS', 16)

                #trick to keep the screen running:
                pygame.event.pump()
                                
                self.screen.blit(self.bg, (0,0))

                # Draw car running
                # TODO : change the car orientation and resize perhapes
                car_img_angle = pygame.transform.rotate(self.car_img, -self.angle)
                self.screen.blit(car_img_angle, (self.car))

                # show dabba and delivery
                self.screen.blit(self.dabba, (self.x1-30, self.y1-30))
                self.screen.blit(self.delivery, (self.x2-50, self.y2-50))
                

                if self.last_reward < -0.6:
                    reward_text = myfont.render('Reward: '+str(self.last_reward), False, (255, 0, 0))
                else:
                    reward_text = myfont.render('Reward: '+str(self.last_reward), False, (0, 255, 0))
                self.screen.blit(reward_text,(1280,500))
                
                # the surrounding stuff            
                #TODO: use LIDAR values from the CNN Model
                self.screen.blit(self.surr, (1160,500))
                surr_text = myfont.render('Surr', False, (0, 0, 255))
                self.screen.blit(surr_text,(1160,550))

                self.screen.blit(self.lidar, (1220,500))
                lidar_text = myfont.render('Lidar', False, (0, 0, 255))
                self.screen.blit(lidar_text,(1220,550))


                pygame.display.update()
                clock.tick(self.metadata["video.frames_per_second"])
                
                #trick to quit the screen
                for event in pygame.event.get():
                    if event.type == pygame.QUIT:
                        pygame.quit()

                
        else:
            raise error.UnsupportedMode("Rebder mode is Unsupported: " + mode)

    def step(self, action):
        """
        This method steps the game forward one step and moves the car one step = [x,y]+vector(speed, angle)

        Parameters
        ----------
        action : int
            The action is an angle between -20 and 20 degrees,
            decides new angle of the car;
            angle = angle + action
            also speed [-20,20] scaled b/w [3,5]

        Returns
        -------
        ob, reward, episode_over/done, info : tuple
            ob (object) :
                an environment-specific object representing the
                state of the environment.here is's a dictionary
                "surroud": 40x40 grid,
                "orientation": (1)Direction of the car with respect to the goal (in + and -)
                                (if the car is heading perfectly towards the goal, then orientation = 0)
                                possibly calculated by Vector(*self.car.velocity).angle((xx,yy))/180
                                (2) angle of the car(in + and -)
                                [distance, orientation, -orientation, angle, -angle]


            reward (float) :(maybe int)
                amount of reward achieved by the previous action.
            episode_over (bool) : done
                whether it's time to reset the environment again.
            info (dict) :
                Kuch ankahi si baatein. :'D
        """
     
        # move the freakin car
        self.angle, self.car.centerx, self.car.centery = self._move_car(action)
        reward, done = self._reward_calc()
        state = self._get_state()

        surr = state["surround"].reshape(self.state_size,self.state_size)*255
        self.surr = pygame.surfarray.make_surface(surr)
        #Trickery TODO: Use CNN output to show lidar values
        lidar = skimage.measure.block_reduce(surr, (8,8), np.max)
        self.lidar = pygame.surfarray.make_surface(np.kron(lidar, np.ones((8,8))))

        return state, reward, done, {}
    
    def _reward_calc(self, reward = 0, done = False):
        """
        Total Positive rewards AKA COcaine =  number of steps in episode * tax
        TODO: too many ifs and buts// Use some Math
        """
        # Calculate the distance after moving
        distance = np.sqrt((self.car.centerx - self.goal_x)**2 + (self.car.centery - self.goal_y)**2) # getting the new distance between the car and the goal right after the car moved
        # reward = 0
        # let's get to rewards// make them complicated
        if self.sand[int(self.car.centery), int(self.car.centerx)] > 0: # if the car is on the sand
            reward = -1.5
            # if distance < self.last_distance:
            #     reward = -0.995
        else: # being on road
            reward = -0.6
            if distance < self.last_distance:
                reward = -0.01
        
        
        # Point A as goal has been given in Reset
        if distance < 30 and not done: #when reaches somewhere
            if self.swap==1:
                reward = 2 # Double cocaine
                done = True
            else: # reached A
                self.goal_x, self.goal_y = self.x2, self.y2
                self.x1, self.y1 = self.car.centerx, self.car.centery # dabba attached to car
                # reward = 1 # Cocaine
                self.swap = 1
        #take the dabba with car
        if self.swap == 1:
            self.x1, self.y1 = self.car.centerx, self.car.centery # dabba attached to car
        
        # Updating the last distance from the car to the goal and reward
        self.last_distance = distance
        self.last_reward = reward

        return reward, done


    def _move_car(self, action):
        """
        Moves the car forward.
        action is rotation of the car
        """
        # update the freaking angle first

        self.angle = self.angle%360
        # self.angle = (self.angle + action)%360
        self.angle = (self.angle + action[0])%360
        self.speed = np.interp(action[1], (-self.max_action, self.max_action), (3, 5)) # between [1,5]

        # print(car.centerx, car.centery)
        #get the new x, y
        self.car.centerx, self.car.centery = self._new_xy(self.car.centerx,
                                                          self.car.centery,
                                                          self.speed,
                                                          self.angle)
        # print(car.centerx,car.centery)
        print(f'Predicted Action: {action[0]:.2f}, speed: {self.speed:.2f}, Reward: {self.last_reward:.2f} and Distance: {self.last_distance}')

        # Collision control and not letting car move out of boundary
        # collision with left wall
        if self.car.centerx  < 0:
            self.car.centerx = 0
        # collision with right wall
        if self.car.centerx >= self.window_width-self.car.height:
            self.car.centerx = self.window_width-self.car.height
        # collision with top wall
        if self.car.centery < 0:
            self.car.centery = 0
        # collision with bottom wall
        if self.car.centery >= self.window_height-self.car.height:
            self.car.centery = self.window_height-self.car.height
        return self.angle, self.car.centerx, self.car.centery

    def _new_xy(self, x, y, speed, angle):
        """
        new position of car after one timestamp and single velocity value
        """
        new_x = x + int(speed * math.cos(math.radians(angle)))
        new_y = y + int(speed * math.sin(math.radians(angle)))
        # print(new_x, new_y)
        return new_x, new_y

    def _get_state(self):
        """
        This function returns the current game state.
        state["surround"] = 40x40
        spaces.Box(low=0, high=255, shape=(screen_height, screen_width, 3), dtype=np.uint8)

        state["orientation"] = [distance, orientation, -orientation, self.angle, -self.angle]
        """
        state = {}

        
        # new_sand = self.sand.view(extendsand)
        
        state['surround'] = self._subimage(crop_size=self.state_size) # makes it (crop_size//2)x(crop_size//2)

        # direction of the car with respect to the goal (if the car is heading perfectly towards the goal, then orientation = 0)
        xx = self.goal_x - self.car.centerx # difference of x-coordinates between the goal and the car
        yy = self.goal_y - self.car.centery # difference of y-coordinates between the goal and the car
        orientation = math.degrees(math.atan2(yy, xx))%360 # orientation from goal
        
        distance = np.sqrt((self.car.centerx - self.goal_x)**2 + (self.car.centery - self.goal_y)**2) # getting the new distance between the car and the goal right after the car moved

        state["orientation"] = np.asarray([distance, orientation, -orientation, self.angle, -self.angle], dtype = np.float32)
        # state["orientation"] = np.asarray([distance, orientation - self.angle], dtype = np.float32)
        return state


    def _subimage(self, crop_size=80): # crop size will later be 2x2 maxpool to make 40x40 or not 
        #200 padding to avoid out of limit cropping at edges
        pad = 100
        crop1 = np.pad(self.sand, pad_width=pad, mode='maximum') # maximum is 1 in the mask1
        centerx = self.car.centerx + pad
        centery = self.car.centery + pad

        #smaller cutout to rotate and save memory 
        startx = int(centerx-(crop_size*2))
        starty = int(centery-(crop_size*2))
        crop1 = crop1[starty:starty+crop_size*4, startx:startx+crop_size*4]

        # why did I make it complicated?????
        shape = ( crop1.shape[1], crop1.shape[0] ) # cv2.warpAffine expects shape in (length, height)
        center = (crop1.shape[1]//2, crop1.shape[0]//2)
        matrix = cv2.getRotationMatrix2D( center=center, angle= -self.angle, scale=1 )
        crop1 = cv2.warpAffine( src=crop1, M=matrix, dsize=shape )
        crop1 = crop1.clip(min=0) # remove negative number due to interpolation for rotation
        center = (crop1.shape[1]//2, crop1.shape[0]//2)

        x = int( center[0] - crop_size//2) 
        y = int( center[1] - crop_size//2 ) 

        crop1 = crop1[ y:y+crop_size, x:x+crop_size ]
        # crop1 = np.rot90(crop1) # 90 degree to see the car's front view on top
        return crop1.reshape(crop_size, crop_size, 1)
        

    def seed(self, seed=None):
        self.np_random, seed = seeding.np_random(seed)
        return [seed]

# Running the whole thing just to diagnose
# if __name__ == '__main__':
#     # state = DabbeWalaEnv().reset()
# #     print(state)
# #     print(state.shape)
# #     print(state)
#     # print(DabbeWalaEnv().action_space[0])
# #     # orientation
#     a = DabbeWalaEnv()
#     a.reset()
#     print(a.x1,a.y1,a.x2,a.y2 )
#     b = DabbeWalaEnv()
#     b.reset()
#     print(b.x1,b.y1,b.x2,b.y2 )
    
#     # from matplotlib import pyplot as plt
#     # plt.imshow(state.reshape(40,40), interpolation=None)
#     # plt.show()